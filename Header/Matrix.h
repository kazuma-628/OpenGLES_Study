#ifndef MATRIX_H
#define MATRIX_H

//include定義
#include "Common.h"

//Define定義
#define DEGREE_TO_RADIAN(degree) ((degree * (float)M_PI) / 180.0f)
#define M_PI (3.14159265358979323846)

class Matrix
{

public:
	//コンストラクタ
	Matrix();

	//デストラクタ
	~Matrix();

	/*-------------------------------------------------------------------------------
	*	関数説明
	*	　演算子のオーバーロード定義
	*-------------------------------------------------------------------------------*/
	friend Matrix operator*(Matrix& p_left, Matrix& p_right);

	/*-------------------------------------------------------------------------------
	*	関数説明
	*	　単位行列を生成する
	*	引数
	*	　なし
	*	戻り値
	*	　なし
	*-------------------------------------------------------------------------------*/
	void Identity();

	/*-------------------------------------------------------------------------------
	*	関数説明
	*	　移動行列を適応する
	*	引数
	*	　p_x	：[I/ ]　X 座標の移動量
	*	　p_y	：[I/ ]　Y 座標の移動量
	*	　p_z	：[I/ ]　Z 座標の移動量
	*	戻り値
	*	　なし
	*-------------------------------------------------------------------------------*/
	void Translate(const GLfloat p_x, const GLfloat p_y, const GLfloat p_z);

	/*-------------------------------------------------------------------------------
	*	関数説明
	*	　拡大/縮小行列を適応する
	*	引数
	*	　p_x	：[I/ ]　X 座標の倍率
	*	　p_y	：[I/ ]　Y 座標の倍率
	*	　p_z	：[I/ ]　Z 座標の倍率
	*	戻り値
	*	　なし
	*-------------------------------------------------------------------------------*/
	void Scale(const GLfloat p_x, const GLfloat p_y, const GLfloat p_z);

	/*-------------------------------------------------------------------------------
	*	関数説明
	*	　回転行列を適応する
	*	引数
	*	　p_rotate	：[I/ ]　回転角度（360度系）
	*	　下記、回転軸となる正規化された方向ベクトルを設定する
	*	　p_x		：[I/ ]　X 座標（X 成分に効かせる場合は 1.0 を指定）
	*	　p_y		：[I/ ]　X 座標（Y 成分に効かせる場合は 1.0 を指定）
	*	　p_z		：[I/ ]　X 座標（Z 成分に効かせる場合は 1.0 を指定）
	*	戻り値
	*	　なし
	*-------------------------------------------------------------------------------*/
	void Rotate(const GLfloat p_rotate, const GLfloat p_x, const GLfloat p_y, const GLfloat p_z);
	
	/*-------------------------------------------------------------------------------
	*	関数説明
	*	　透視投影変換行列を適応する
	*	　一つ下にある「Perspective」関数でも行列を作成することが可能です（オーバーロードしてあります）
	*	　引数が違うので、使いやすい方や用途に合わせて使用すること（結果的には同じことができます）
	*	引数
	*	　p_left	：[I/ ]　近くの面(p_near面)の左側までの距離
	*	　p_right	：[I/ ]　近くの面(p_near面)の右側までの距離
	*	　p_bottom	：[I/ ]　近くの面(p_near面)の下側までの距離
	*	　p_top		：[I/ ]　近くの面(p_near面)の上側までの距離
	*	　p_near	：[I/ ]　近くの面までの距離
	*	　p_far		：[I/ ]　遠くの面までの距離
	*
	*	　図は下記URLの「透視投影変換」項目参照
	*	　http://marina.sys.wakayama-u.ac.jp/~tokoi/?date=20090829
	*	戻り値
	*	　なし
	*-------------------------------------------------------------------------------*/
	void Perspective(float p_left, float p_right,
					float p_bottom, float p_top,
					float p_near, float p_far);
	
	/*-------------------------------------------------------------------------------
	*	関数説明
	*	　透視投影変換行列を適応する
	*	　一つ上にある「Perspective」関数でも行列を作成することが可能です（オーバーロードしてあります）
	*	　引数が違うので、使いやすい方や用途に合わせて使用すること（結果的には同じことができます）
	*	引数
	*	　p_near		：[I/ ]　近くの面までの距離
	*	　p_far			：[I/ ]　遠くの面までの距離
	*	　p_fovY_deg	：[I/ ]　カメラの Y方向の画角
	*	　p_aspect		：[I/ ]　描画先の画面のアスペクト比（幅 ÷ 高さ）
	*
	*	戻り値
	*	　なし
	*-------------------------------------------------------------------------------*/
	void Perspective(float p_near, float p_far,
					float p_fovY_degree, float p_aspect);

	/*-------------------------------------------------------------------------------
	*	関数説明
	*	　逆行列を求める
	*	引数
	*	　なし
	*	戻り値
	*	　逆行列
	*-------------------------------------------------------------------------------*/
	Matrix Inverse() const;
	

	/*-------------------------------------------------------------------------------
	*	関数説明
	*	　行列の値を取得する
	*	引数
	*	　なし
	*	戻り値
	*	　行列の値
	*-------------------------------------------------------------------------------*/
	const GLfloat* GetMatrix();

private:

	//行列用の配列
	//
	//[ 0][ 1][ 2][ 3]
	//[ 4][ 5][ 6][ 7]
	//[ 8][ 9][10][11]
	//[12][13][14][15]
	//
	GLfloat m_val[16];
};
#endif